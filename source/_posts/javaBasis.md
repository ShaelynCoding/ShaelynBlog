---
title: Java基础知识
date: 2022-03-16 20:08:22
tags:
categories:
  - java
---

## Java语言特点
- 面向对象（封装，继承，多态）
- 平台无关性，一次编写，随处运行(Write once, run anywhere) -> 跨平台；保证这一点的正是JVM机制
- 支持多线程（C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）
- 编译与解释并存
<!--more-->

## 比较需要关注的方面:
- jvm 内存区域/垃圾回收
- 类加载过程 class loader
- 反射/泛型/lamda
- IO/NIO
- 解释执行/动态编译

## JVM、JDK、JRE的区别
JVM：Java Virtual Machine，Java 虚拟机，Java 程序运行在 Java 虚拟机上。针对不同系统的实现（Windows，Linux，macOS）不同的 JVM，因此 Java 语言可以实现跨平台。

JRE： Java Runtime Environment, Java 运⾏时环境。它是运⾏已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，Java 命令和其他的⼀些基础构件。但是，它不能⽤于创建新程序。

JDK: Java Development Kit，它是功能⻬全的 Java SDK。它拥有 JRE 所拥有的⼀切，还有编译器（javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。

![JVM、JDK和JRE](jvm_jdk_jre.png)

## Java源代码运行过程
字节码: JVM可以理解的代码，即扩展名为.class的文件。（java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点）
![compile](compile.png)

JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。

我们可以将高级编程语言按照程序的执行方式分为两种：

**编译型** ：编译型语言 会通过编译器将源代码**一次性翻译**成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。

**解释型** ：解释型语言会通过解释器**一句一句**的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。

**Java 语言既具有编译型语言的特征，也具有解释型语言的特征**。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。

## 自动拆箱/封箱
装箱：将基本类型用它们对应的引用类型包装起来；
拆箱：将包装类型转换为基本数据类型；
装箱其实就是调用了包装类的`valueOf()`方法，拆箱其实就是调用了`xxxValue()`方法。
`Integer i = 10` 等价于 `Integer i = Integer.valueOf(10)`
`int n = i` 等价于 `int n = i.intValue()`;
**如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。**

## 面向对象三大特征
1. 封装
封装是指把*一个对象的状态信息（也就是属性）*隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界*访问的方法*来操作属性。

2. 继承
不同类型的对象，相互之间经常有一定数量的共同点。同时，每一个对象还定义了额外的特性使得他们与众不同。
继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。

- 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。
- 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
- 子类可以用自己的方式实现父类的方法

3. 多态
通俗来说，就是多种形态，具体点就是去完成某个行为，当不同的对象去完成时会产生出不同的状态。
允许将子类类型的指针赋值给父类类型的指针，把不同的子类对象都当作父类来看。
- 两种形式可以实现多态：继承（多个⼦类对同⼀⽅法的重写）和接⼝（实现接⼝并覆盖接⼝中同⼀⽅法）
- 多态存在的三个必要条件：继承；重写；父类引用指向子类对象：Parent p = new Child();

**重载 overload** 编译时多态，方法名相同，参数列表（类型/个数）不同

**重写 override** 运行时多态，重写要求子类被重写方法与父类被重写方法有相同的返回类型，不能比父类被重写方法声明更多的异常

## 接口 interface和抽象类 abstract class有什么共同点和区别？
接口是对行为的抽象，它是抽象方法的集合，利用接口可以达到 API 定义和实现分离的目的。
共同点 ：
- 都不能被实例化。
- 都可以包含抽象方法。
- 都可以有默认实现的方法（Java 8 可以用 default 关键在接口中定义默认方法）。

区别 ：
- 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系（比如说我们抽象了一个发送短信的抽象类，）。
- 一个类只能继承一个类，但是可以实现多个接口。
- 接口中的成员变量只能是`public static final`类型的，不能被修改且必须有初始值，而抽象类的成员变量默认`default`，可在子类中被重新定义，也可被重新赋值。

## final 关键字有什么作用？
final 表示不可变的意思，可用于修饰类、属性和方法：
- 被 final 修饰的类不可以被继承, 如String

- 被 final 修饰的方法不可以被重写

- 被 final 修饰的变量不可变，被 final 修饰的变量必须被显式第指定初始值，还得注意的是，这里的不可变指的是变量的引用不可变，不是引用指向的内容的不可变。

## java中创建对象的方式
- new 创建新对象
- 通过反射机制
- 采用 clone 机制
- 通过序列化机制

## String、StringBuffer、StringBuilder 的区别？
String：String 的值被创建后不能修改，任何对 String 的修改都会引发新的 String 对象的生成。
StringBuffer：跟 String 类似，但是值可以被修改，使用 synchronized 来保证线程安全。
StringBuilder：StringBuffer 的非线程安全版本，性能上更高一些。
>在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：编译器不会创建单个 StringBuilder 以复用，StringBuilder 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 StringBuilder 对象。

**String 为什么是不可变的?**
- 保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。
- String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。

## Exception/Error
在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类:

Exception :程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。


![Error和Exception](error_exception.webp)

**Checked Exception** 即受检查异常，Java 代码在编译过程中，如果受检查异常没有被 catch/throw 处理的话，就没办法通过编译 。
>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、ClassNotFoundException 、SQLException)

**Unchecked Exception** 即 不受检查异常 ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。

>RuntimeException 及其子类都统称为非受检查异常，例如：NullPointerException、NumberFormatException（字符串转换为数字）、ArrayIndexOutOfBoundsException（数组越界）、ClassCastException（类型转换错误）、ArithmeticException（算术错误）等)

Error ：Error 属于程序无法处理的错误 ，不建议通过catch捕获 。例如Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。

## ==和equals的区别
== 对于基本类型和引用类型的作用效果是不同的:
- 对于基本数据类型来说，==比较的是值
- 对于引用数据类型来说，==比较的是对象的内存地址
> 因为java只有值传递，所有对于==而言，不管是比较基本数据类型还是引用数据类型，本质都是比较值，只是引用类型变量存的值是对象的地址
`equals`的比较：
1. 类没有覆盖`equals()`方法，等价于==，使用的默认是Object类equals()方法
2. 类覆盖了`equals()`方法，一般都会覆盖`equals()`方法来比较两个对象的值是否相等，如String
### equals() / hashcode()
- 如果两个对象的hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。 
- 如果两个对象的hashCode 值相等并且equals()方法返回 true，我们才认为这两个对象相等。 
- 如果两个对象的hashCode 值不相等，我们就可以直接认为这两个对象不相等。

## Java 中 IO 流
- 按照流的流向分，可以分为输入流和输出流；
- 按照操作单元划分，可以划分为字节流和字符流；
- 按照流的角色划分为节点流和处理流。

Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的:
InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。
OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

按操作方式分类结构图：


![Java IO](IO.png)

## 既然有了字节流,为什么还要有字符流?
>问题本质想问：不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？

回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。

## 泛型

## 序列化