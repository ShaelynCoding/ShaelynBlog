---
title: jvm
date: 2022-03-21 11:55:14
tags:
categories:
 - java
---
JVM(Java Virtual Machine) - Java 虚拟机，它是 Java 实现平台无关性的基石。

Java 程序运行的时候，编译器将 Java 文件编译成平台无关的 Java 字节码文件（.class）,接下来对应平台 JVM 对字节码文件进行解释，翻译成对应平台匹配的机器指令并运行。
<!--more-->
## JVM 内存区域
Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。
JDK 1.6
![JDK1.6 运行时数据区域](运行时区域_JDK1.6.png)
JDK 1.8
![JDK1.8 运行时数据区域](运行时区域_JDK1.8.png)

线程私有的：
- 程序计数器
- 虚拟机栈
- 本地方法栈

线程共享的：
- 堆
- 方法区
- 直接内存 (非运行时数据区的一部分)

### 程序计数器
程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令**，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。

另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。

从上面的介绍中我们知道程序计数器主要有两个作用：

字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

### Java虚拟栈
Java 虚拟机栈描述的是 Java 方法执行的线程内存模型：方法执行时，JVM 会同步创建一个栈帧，用来存储局部变量表、操作数栈、动态连接等。

>Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。
StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。
OutOfMemoryError： Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。

### 本地方法栈
虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。（ 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。）

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

### 堆
Java 堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java 里“几乎”所有的对象实例都在这里分配内存。

Java 堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC 堆”（Garbage Collected Heap）。从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以 Java 堆中经常会出现新生代、老年代、Eden空间、From Survivor空间、To Survivor空间等名词，需要注意的是这种划分只是根据垃圾回收机制来进行的划分，不是 Java 虚拟机规范本身制定的。

### 方法区
方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。

方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。

**方法区和永久代的关系**

>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。

**常用参数**

JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小
```java
-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
```
相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。

JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。

下面是一些常用参数：
```java
-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```
与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。

**为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?**

1.整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。
>当元空间溢出时会得到如下错误： java.lang.OutOfMemoryError: MetaSpace

你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX：MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。

2.元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。

3.在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。


下图来自《深入理解 Java 虚拟机》第 3 版 2.2.5
![MetaSpace](metaSpace.png)

### 运行时常量池

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。

JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代
JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代 。
JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)

### 直接内存
直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。

## 对象的创建过程
new一个新的对象，首先查看类是否加载
如果已经加载 => 分配内存空间 => 实例变量赋默认值 => 设置对象头 => 执行初始化方法
未加载 => 类加载 => 连接（验证=>准备=>解析）=> 初始化
> 分配内存空间：
1. 指针碰撞，用
2. 空闲列表

## 类的生命周期

加载 =>  连接（验证=>准备=>解析）=> 初始化 => 使用 => 卸载
**加载**
1. 将字节码转成二进制字节流
2. 二进制字节流所代表的静态存储结构转换到方法去的运行时数据结构
3. 在内存生成class对象

**验证**
1. 文件格式验证：验证字节流是否符合class文件格式规范
2. 元数据验证：如此类是否有父类，收否继承了不允许被继承的累
3. 字节码验证
4. 符号引用验证

**准备**
为静态变量，常量分配内存并赋默认值（实例变量会在对象实例化时随对象分配在java堆中）

**解析**
把常量池中符号引用（符号描述引用目标）转换成直接引用（指向目标的指针或句柄）

**初始化**
执行static代码块进行初始化，如果存在父类，先对父类进行初始化

**卸载**
条件（如何判断一个类是无用的类）：
1. 该类的所有的实例对象都被GC(堆不存在该类的实例对象)
2. 该类没有再其他任何地方被引用
3. 该类的类加载器的实例已被GC

## 双亲委派机制
Java类加载器从上至下为：
- bootstrap classloader   启动类加载器
- extension classloader   扩展类加载器
- application classloader 应用程序类加载器
- user classloader        用户自定义类加载器
加载类的时候自下而上查询父类加载器是否已加载当前类，如果没有从顶向下加载该类
**什么场景需要自定义user classloader**
- 隔离加载器：在框架内进行中间件与应用的模块隔离，把类加载到不同的环境
- 修改类加载的方式
- 扩展加载源
- 防止源码泄露：java代码容易被编译和篡改，可以进行编译加密 => 自定义累加器还原加密字节码


## 垃圾回收
![Java Heap](java_heap.png)


## 如何判断对象是否死亡
1. 引用计数法
引用=> count+1; 引用结束=> count-1; 如果count=0=>无引用。但是无法解决循环引用的问题
2. 可达性分析
如果GC root到对应有引用链路说明该对象可达，如果没有可达引用链，则死亡
**可作为GC root的对象**
1. 虚拟机栈中引用对象
2. 本地native方法引用对象
3. 方法区静态属性引用对象
4. 被同步锁持有的对象

## 简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。
1. 强引用 内存不够都不会被回收的引用对象，会抛出OOM
2. 软引用 内存不够会被回收的引用对象
3. 弱引用 不管内存够不够， gc都会回收的引用对象
4. 虚引用 用于跟踪对象被垃圾回收的活动，一般和引用队列联合使用


## 垃圾收集有哪些算法，各自的特点？
1. 标记 - 清除 通过GC root标记还存活的对象，然后清楚未被标记的对象。
   问题： 空间碎片
2. 标记 - 复制 复制存活的对象到另一块区域，然后整片清空原区域，解决了空间碎片的问题
3. 标记 - 整理 标记所有存货的对象，把标记对象往一端移动
## HotSpot 为什么要分为新生代和老年代？
## 常见的垃圾回收器有哪些？
 serial
 parallel
 CMS
 G1
### 介绍一下 CMS,G1 收集器。
CMS
- 初始标记：寻找GC root直接关联的对象 STW
- 并发标记存活对象
- 重新标记， STW (修正并发标记期间因用户线程产生变动的对象)
- 并发清除
缺点： 碎片空间, 无法清理浮动垃圾；对CPU资源敏感
G1：Garbage first
- 把区域分成几个region
- 初始标记 STW
- 并发标记
- 最终标记 STW
- 筛选回收 STW, 会根据用户设置的停顿注定回收计划（维护一个优先列表，每次根据允许的收集事件优先选择回收价值最大的region), 需要回收的region中的存活对象复制到空的region，同时清理旧的region。
## Minor GC 和 Full GC 有什么不同呢？
Eden区满了之后会触发Minor GC，把存活的对象放到Survivor0, Survivor0满了之后会触发Minor GC，会把存活的对象放到Survivor1，然后from和to指针会交换。
老年代占满了就会触发Full GC，Full GC包括新生代和老年代的GC
老年代空间不足的情况：
1. 占用内存过大的对象会直接保存到老年代，但这个时候老年代空间不足
2. promotion failure: Survivor区存活的对象年龄达到设定值，会将对象拷贝到老年代
## 频繁Full GC

## JVM调优